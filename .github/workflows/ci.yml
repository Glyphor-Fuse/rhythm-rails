name: ci

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

# Concurrency policy:
# - PR checks should NOT be auto-cancelled, or required checks can stay "stuck" as cancelled.
# - Push runs (e.g. main) can still auto-cancel older in-progress runs.
concurrency:
  group: ci-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: ${{ github.event_name != 'pull_request' }}

permissions:
  contents: write
  pull-requests: write

jobs:
  build:
    # Skip CI for template bootstrap commits (first commit when repo is cloned from template)
    if: ${{ !contains(github.event.head_commit.message, '[initial-seed]') && !contains(github.event.head_commit.message, '[skip ci]') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Type check
        run: npm run typecheck

      - name: Lint
        run: npm run lint

      - name: Build
        run: npm run build

  auto-merge:
    # Auto-merge PRs created by Glyphor AI after CI passes
    needs: [build]
    if: ${{ github.event_name == 'pull_request' && needs.build.result == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Enable auto-merge
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            const headRef = context.payload.pull_request.head.ref;
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const repoInfo = await github.rest.repos.get({ owner, repo });
            const allowedMethods = [];
            if (repoInfo.data.allow_merge_commit) allowedMethods.push('merge');
            if (repoInfo.data.allow_squash_merge) allowedMethods.push('squash');
            if (repoInfo.data.allow_rebase_merge) allowedMethods.push('rebase');

            if (allowedMethods.length === 0) {
              throw new Error('No merge methods enabled on repository settings');
            }

            console.log(`Allowed merge methods: ${allowedMethods.join(', ')}`);

            let merged = false;
            let lastError = '';

            // Retry for a few minutes so external required checks (e.g. Vercel) can finish.
            for (let attempt = 1; attempt <= 15 && !merged; attempt++) {
              const pr = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });

              if (pr.data.merged || pr.data.state === 'closed') {
                console.log(`PR #${prNumber} already merged/closed`);
                merged = true;
                break;
              }

              for (const method of allowedMethods) {
                try {
                  await github.rest.pulls.merge({
                    owner,
                    repo,
                    pull_number: prNumber,
                    merge_method: method,
                  });
                  console.log(`PR #${prNumber} merged using ${method} (attempt ${attempt})`);
                  merged = true;
                  break;
                } catch (err) {
                  const msg = err?.message || String(err);
                  lastError = `[${method}] ${msg}`;
                  console.log(`Attempt ${attempt} merge via ${method} failed: ${msg}`);
                }
              }

              if (!merged && attempt < 15) {
                await sleep(20_000);
              }
            }

            if (!merged) {
              throw new Error(`Auto-merge failed after retries: ${lastError || 'unknown error'}`);
            }

            // Delete branch after successful merge (non-fatal if it fails)
            try {
              await github.rest.git.deleteRef({
                owner,
                repo,
                ref: `heads/${headRef}`,
              });
              console.log(`Branch ${headRef} deleted`);
            } catch (delErr) {
              console.log('Branch deletion failed (non-fatal):', delErr.message);
            }
